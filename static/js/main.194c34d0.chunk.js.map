{"version":3,"sources":["avatar.png","UsersList.js","MessageBox.js","MonetizationOff.js","Chat.js","Container.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","UsersList","users","toggleConnection","connectedTo","connecting","avatar","Grid","Column","width","Card","fluid","Content","header","textAlign","length","List","divided","verticalAlign","size","map","user","Item","key","userName","floated","Button","onClick","disabled","loading","Modal","trigger","Image","src","Header","image","wrapped","Description","pointer","JSON","stringify","Segment","MessageBox","messages","message","setMessage","sendMsg","me","Sticky","Message","warning","Comment","Group","sender","text","time","Avatar","Author","Label","pointing","Metadata","formatRelative","Date","Text","placeholder","icon","Icon","name","Form","Input","type","value","onChange","e","target","action","color","MonetizationOff","isMonetized","useContent","href","rel","configuration","iceServers","url","Chat","connection","updateConnection","updateChannel","channel","useState","socketOpen","setSocketOpen","socketMessages","setSocketMessages","isLoggedIn","setIsLoggedIn","setMe","paymentPointer","setPaymentPointer","loggingIn","setLoggingIn","setUsers","setConnectedTo","setConnecting","alert","setAlert","connectedRef","useRef","messagesRef","setMessages","client","onConnect","current","subscribe","console","log","onMessageArrived","payloadString","data","parse","prev","useEffect","clientID","parseInt","Math","random","Paho","Client","Number","connect","useSSL","port","password","onSuccess","pop","onLogin","updateUsersList","send","removeUser","onOffer","onAnswer","error","onCandidate","onChannelMessage","closeAlert","publish","handleDataChannelMessageReceived","filter","u","recipient","peer","peerMessages","newMessages","Object","assign","success","loggedIn","title","timeout","onConfirm","onCancel","localConnection","RTCPeerConnection","ondatachannel","event","receiveChannel","onopen","onmessage","confirmBtnBsStyle","offerMessage","answer","localDescription","candidate","className","as","centered","columns","Field","iconPosition","autoFocus","raised","dataChannel","createDataChannel","onerror","createOffer","then","offer","setLocalDescription","catch","handleConnectToPeer","format","Loader","active","inline","Container","ConnectionConsumer","ChannelConsumer","ConnectionContext","createContext","ChannelContext","Consumer","App","setconnection","setChannel","Provider","conn","chn","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.194c34d0.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/avatar.315cf354.png\";","// Displays list of users on the left\nimport React from \"react\";\nimport {\n  Grid,\n  Segment,\n  Card,\n  List,\n  Button,\n  Image,\n  Modal,\n  Header\n} from \"semantic-ui-react\";\n\nconst UsersList = ({ users, toggleConnection, connectedTo, connecting }) => {\n  const avatar = \"https://avatars.dicebear.com/api/human/moneychat.svg\"\n  return (\n    <Grid.Column width={5}>\n      <Card fluid>\n        <Card.Content header=\"Online Users\" />\n        <Card.Content textAlign=\"left\">\n          {(users.length && (\n            <List divided verticalAlign=\"middle\" size=\"large\">\n              {users.map((user) => (\n                <List.Item key={user.userName}>\n                  <List.Content floated=\"right\">\n                    <Button\n                      onClick={() => {\n                        toggleConnection(user.userName);\n                      }}\n                      disabled={!!connectedTo && connectedTo !== user.userName}\n                      loading={connectedTo === user.userName && connecting}\n                    >\n                      {connectedTo === user.userName ? \"Disconnect\" : \"Connect\"}\n                    </Button>\n                  </List.Content>\n                  <Modal trigger={<Image avatar src={avatar} />}>\n    <Modal.Header>A Money Chat User</Modal.Header>\n    <Modal.Content image>\n      <Image wrapped size='medium' src={avatar} />\n      <Modal.Description>\n        <Header>{user.userName}</Header>\n        <p>\n          Payment Pointer: {user.pointer}\n        </p>\n        <p>\n          {JSON.stringify(user,null,2)}\n        </p>\n      </Modal.Description>\n    </Modal.Content>\n  </Modal>\n                  <List.Content>\n                    <List.Header>{user.userName}</List.Header>\n                  </List.Content>\n                </List.Item>\n              ))}\n            </List>\n          )) || <Segment>There are no users Online</Segment>}\n        </Card.Content>\n      </Card>\n    </Grid.Column>\n  );\n};\n\nexport default UsersList;\n","// This is the message area\nimport React from \"react\";\nimport {\n  Header,\n  Icon,\n  Input,\n  Grid,\n  Segment,\n  Card,\n  Sticky,\n  Button,\n  Comment,\n  Form,\n  Label,\n  Message\n} from \"semantic-ui-react\";\nimport { formatRelative } from \"date-fns\";\nimport avatar from \"./avatar.png\";\n\nconst MessageBox = ({ messages, connectedTo, message, setMessage, sendMsg, me }) => {\n  return (\n    <Grid.Column width={11}>\n      <Sticky>\n        <Message warning>\n          <Message.Header>Nothing here is private! All messages are sent to everyone on this site.</Message.Header>\n        </Message>\n        <Card fluid>\n          <Card.Content\n            header={\n              !!connectedTo ? connectedTo : \"Not chatting with anyone currently\"\n            }\n          />\n          <Card.Content>\n            {!!connectedTo && messages[connectedTo] ? (\n              <Comment.Group>\n                {messages[connectedTo].map(({ sender, message: text, time }) => (\n                  <Comment key={`msg-${sender}-${time}`}>\n                    <Comment.Avatar src={avatar} />\n                    <Comment.Content>\n                      <Comment.Author><Label pointing={sender === me ? 'right' : 'left'}>{sender === me ? 'Me' : sender}</Label></Comment.Author>\n                      <Comment.Metadata>\n                        <span>\n                          {formatRelative(new Date(time), new Date())}\n                        </span>\n                      </Comment.Metadata>\n                <Comment.Text>{text}</Comment.Text>\n                    </Comment.Content>\n                  </Comment>\n                ))}\n              </Comment.Group>\n            ) : (\n              <Segment placeholder>\n                <Header icon>\n                  <Icon name=\"discussions\" />\n                  No messages available yet\n                </Header>\n              </Segment>\n            )}\n            <Form>\n            <Input\n              fluid\n              type=\"text\"\n              value={message}\n              onChange={e => setMessage(e.target.value)}\n              placeholder=\"Type message\"\n              action\n            >\n              <input />\n              <Button color=\"teal\" disabled={!message} onClick={sendMsg}>\n                <Icon name=\"send\" />\n                Send Message\n              </Button>\n            </Input>\n            </Form>\n          </Card.Content>\n        </Card>\n      </Sticky>\n    </Grid.Column>\n  );\n};\n\nexport default MessageBox;\n","import React, { Fragment } from \"react\"\nimport { useContent } from 'react-monetize'\n\nfunction MonetizationOff() {\n    const { isMonetized } = useContent()\n    // console.log(\"isMonetized\",isMonetized)\n    // console.log(\"isLoading\", isLoading)\n    return (\n        <Fragment>\n        {\n            !isMonetized ? \n            <div>\n                You do not have monetization enabled.\n                To get the full experience please \n                <a href=\"https://webmonetization.org/docs/getting-started.html\" target=\"_blank\" rel=\"noopener noreferrer\">Get Started!</a>\n            </div>\n            : \n            <div>Monetization Enabled. Thanks for your support!</div>\n        }\n      </Fragment>\n    )\n}\n\nexport default MonetizationOff;\n","import React, { Fragment, useState, useEffect, useRef } from \"react\";\nimport {\n  Header,\n  Icon,\n  Input,\n  Grid,\n  Segment,\n  Button,\n  Loader,\n  Form,\n  Label\n} from \"semantic-ui-react\";\nimport SweetAlert from \"react-bootstrap-sweetalert\";\nimport { format } from \"date-fns\";\nimport \"./App.css\";\nimport UsersList from \"./UsersList\";\nimport MessageBox from \"./MessageBox\";\nimport Paho from \"paho-mqtt\"\nimport MonetizationOff from './MonetizationOff'\n\n// Use for remote connections\nconst configuration = {\n  iceServers: [{ url: \"stun:stun.1.google.com:19302\" }]\n};\n\n// Use for local connections\n// const configuration = null;\n\nconst Chat = ({ connection, updateConnection, channel, updateChannel }) => {\n  const [socketOpen, setSocketOpen] = useState(false);\n  const [socketMessages, setSocketMessages] = useState([]);\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  const [me, setMe] = useState(\"\");\n  const [paymentPointer, setPaymentPointer] = useState(\"\");\n  const [loggingIn, setLoggingIn] = useState(false);\n  const [users, setUsers] = useState([]);\n  const [connectedTo, setConnectedTo] = useState(\"\");\n  const [connecting, setConnecting] = useState(false);\n  const [alert, setAlert] = useState(null);\n  const connectedRef = useRef();\n  //const webSocket = useRef(null);\n  const [message, setMessage] = useState(\"\");\n  const messagesRef = useRef({});\n  const [messages, setMessages] = useState({});\n\n  const client = useRef(null)\n\n  useEffect(() => {\n    // webSocket.current = new WebSocket(process.env.REACT_APP_WEBSOCKET_URL);\n    // webSocket.current.onmessage = message => {\n    //   const data = JSON.parse(message.data);\n    //   setSocketMessages(prev => [...prev, data]);\n    // };\n    // webSocket.current.onclose = () => {\n    //   webSocket.current.close();\n    // };\n    // return () => webSocket.current.close();\n\n    //webSocket.current = new WebSocket('wss://bitcoinofthings.com:8884');\n\n    const clientID = \"bot-demo-ws-\" + parseInt(Math.random() * 100);\n    const host = \"mqtt.bitcoinofthings.com\"\n    const port = \"8884\"\n    const isSSL = true\n    const usessl = (isSSL && port === \"8884\")\n    const username = \"demo\"\n    const password = \"demo\"\n    client.current = new Paho.Client(host, Number(port), clientID)\n    // Set callback handlers\n    //client.onConnectionLost = onConnectionLost\n    client.current.onMessageArrived = onMessageArrived\n    client.current.connect({ \n      useSSL: usessl,\n      userName: username,\n      password: password,\n      onSuccess: onConnect\n    })\n\n  }, []);\n\n  // Called when the client connects\nfunction onConnect() {\n  setSocketOpen(true);\n  client.current.subscribe(\"demo\");\n  console.log(\"subscribed to demo topic\")\n}\n\n// Called when a message arrives on mqtt topic\nfunction onMessageArrived(message) {\n  console.log(\"onMessageArrived: \" + message.payloadString);\n  const data = JSON.parse(message.payloadString)\n  setSocketMessages(prev => [...prev, data])\n}\n\n  useEffect(() => {\n    let data = socketMessages.pop();\n    if (data) {\n      console.log(\"effect data\")\n      console.log(data)\n      switch (data.type) {\n        case \"connect\":\n          setSocketOpen(true);\n          break\n        case \"login\":\n          // we sent the login message\n          if (data.name === me) onLogin(data)\n          else {\n            // someone else logged in. add to our list of users\n            updateUsersList(data.users[0])\n            // broadcast ourselves so that new user sees us\n            if (me) {\n              send({ type: \"updateUsers\",\n                key: me,\n                userName: me,\n                pointer: paymentPointer\n              })\n            }\n          }\n          break\n        case \"updateUsers\":\n          updateUsersList(data);\n          break\n        case \"removeUser\":\n          removeUser(data)\n          break\n        case \"offer\":\n          onOffer(data)\n          break\n        case \"answer\":\n          if (!data.sender) {\n            console.error('INVALID answer message')\n          } else {\n            onAnswer(data)\n          }\n          break\n        case \"candidate\":\n          onCandidate(data);\n          break\n        case \"channelMessage\":\n          onChannelMessage(data);\n          break\n        default:\n          console.log(`${data.type} type not handled in switch`)\n          console.log(data)\n          break\n      }\n    }\n  }, [socketMessages]);\n\n  const closeAlert = () => {\n    setAlert(null);\n  };\n\n  const send = data => {\n    //webSocket.current.send(JSON.stringify(data));\n    console.log('sending')\n    console.log(data)\n    client.current.publish(\"demo\",JSON.stringify(data))\n  }\n\n  //was { data }\n  const onChannelMessage = (data) => {\n    handleDataChannelMessageReceived(data)\n  }\n\n  const handleLogin = () => {\n    setLoggingIn(true);\n    // todo: broker should do login\n    // for now, in demo mode\n    // users should be array of logged in users\n    // back end will need to maintain\n    send({ type: \"login\",\n      name: me,\n      success: true,\n      message:\"I just logged in\",\n      users: [{key:me, userName: me, pointer: paymentPointer}]\n    });\n  };\n\n  // was { user }\n  const updateUsersList = (user) => {\n    removeUser(user)\n    user.avatar = `https://avatars.dicebear.com/api/human/${user.userName}.svg`\n    setUsers(prev => [...prev, user]);\n  };\n\n  //was { user }\n  const removeUser = (user) => {\n    setUsers(prev => prev.filter(u => u.userName !== user.userName));\n  }\n\n  //message received from user in channel\n  //TODO: refactor messages model\n  // really should be conversations[sender]/messages\n  const handleDataChannelMessageReceived = (data) => {\n    //todo: group messages are also sent here\n    if (!(data.recipient === me || data.sender === me)) return\n    const message = data //JSON.parse(data);\n    //const { name: user } = message\n    const sender = message.sender\n    const recipient = message.recipient\n    const peer = (sender === me) ? recipient : sender\n    // list of conversations we have had\n    let conversations = messagesRef.current\n    let peerMessages = conversations[peer]\n    if (peerMessages) {\n      //load previous conversation with our peer\n      console.log(\"previous convo\")\n      peerMessages = [...peerMessages, message]\n      let newMessages = Object.assign({}, messages, { [peer]: peerMessages })\n      messagesRef.current = newMessages\n      setMessages(newMessages)\n      console.log(newMessages)\n    } else {\n      // start a new conversation with peer\n      console.log(\"new convo\")\n      peerMessages = { [peer]: [message] }\n      let newMessages = Object.assign({}, messages, peerMessages)\n      messagesRef.current = newMessages\n      setMessages(newMessages)\n      console.log(newMessages)\n    }\n  }\n\n  const onLogin = ({ success, message, users: loggedIn }) => {\n    setLoggingIn(false)\n    if (success) {\n      setAlert(\n        <SweetAlert\n          success\n          title={`Hello ${me}`}\n          timeout={3000}\n          onConfirm={closeAlert}\n          onCancel={closeAlert}\n        >\n          Logged in successfully!\n        </SweetAlert>\n      )\n      setIsLoggedIn(true)\n      updateUsersList(loggedIn[0])\n\n      //setup connection to peer\n      //for now this is required. try to replace\n      //can we pass webrtc message over mqtt???\n      let localConnection = new RTCPeerConnection(configuration);\n      //when the browser finds an ice candidate we send it to another peer\n      // localConnection.onicecandidate = ({ candidate }) => {\n      //   let connectedTo = connectedRef.current;\n\n      //   if (candidate && !!connectedTo) {\n      //     send({\n      //       name: connectedTo,\n      //       type: \"candidate\",\n      //       candidate\n      //     });\n      //   }\n      // };\n      localConnection.ondatachannel = event => {\n        console.log(\"Data channel is created!\");\n        let receiveChannel = event.channel;\n        receiveChannel.onopen = () => {\n          console.log(\"Data channel is open and ready to be used.\");\n        };\n        receiveChannel.onmessage = handleDataChannelMessageReceived;\n        updateChannel(receiveChannel);\n      };\n      updateConnection(localConnection);\n    } else {\n      setAlert(\n        <SweetAlert\n          warning\n          confirmBtnBsStyle=\"danger\"\n          title=\"Failed\"\n          onConfirm={closeAlert}\n          onCancel={closeAlert}\n        >\n          {message}\n        </SweetAlert>\n      );\n    }\n  };\n\n  //when somebody wants to connect to us\n  // was { offer, name }\n  const onOffer = (offerMessage) => {\n    if (offerMessage.peer !== me) return\n    setConnectedTo(offerMessage.sender);\n    connectedRef.current = offerMessage.sender;\n\n    // connection\n    //   .setRemoteDescription(new RTCSessionDescription(offer))\n    //   .then(() => connection.createAnswer())\n    //   //erroring, not sure what it does\n    //   //.then(answer => connection.setLocalDescription(answer))\n    //   .then(() =>\n        // send answer from us to offer sender\n        send({ type: \"answer\", \n          answer: connection.localDescription, \n          sender: me, \n          peer: offerMessage.sender \n        })\n      // )\n      // .catch(e => {\n      //   console.log({ e });\n      //   setAlert(\n      //     <SweetAlert\n      //       warning\n      //       confirmBtnBsStyle=\"danger\"\n      //       title=\"Failed\"\n      //       onConfirm={closeAlert}\n      //       onCancel={closeAlert}\n      //     >\n      //       There was an error accepting offer.\n      //     </SweetAlert>\n      //   );\n      // });\n  }\n\n  //when a peer answers our offer\n  // was { answer }\n  const onAnswer = (answer) => {\n    if (answer.sender !== me) return\n    console.log(`thanks for accepting. you are now connected to ${answer.peer}`)\n    //connection.setRemoteDescription(new RTCSessionDescription(answer));\n  };\n\n  //when we got ice candidate from another user\n  const onCandidate = ({ candidate }) => {\n    console.log('we dont do ice candidates')\n    //connection.addIceCandidate(new RTCIceCandidate(candidate));\n  };\n\n  //when a user clicks the send message button\n  const sendMsg = () => {\n    const time = format(new Date(), \"yyyy-MM-dd'T'HH:mm:ss.SSSxxx\")\n    //let messages = messagesRef.current\n    let connectedTo = connectedRef.current\n    let messageEntity = { type:\"channelMessage\", time, message, \n      sender: me, recipient: connectedTo || \"group\" }\n    //let userMessages = messages[connectedTo]\n    // if (messages[connectedTo]) {\n    //   userMessages = [...userMessages, text]\n    //   let newMessages = Object.assign({}, messages, {\n    //     [connectedTo]: userMessages\n    //   });\n    //   messagesRef.current = newMessages;\n    //   setMessages(newMessages)\n    // } else {\n    //   userMessages = Object.assign({}, messages, { [connectedTo]: [text] });\n    //   messagesRef.current = userMessages\n    //   setMessages(userMessages)\n    // }\n    //just send it to group, ui will filter out messages\n    // not intended for recipient\n    send(messageEntity)\n    setMessage(\"\")\n  };\n\n  //connect to a peer with offer\n  //we are sender, peer is person we are trying to connect to\n  const handleConnectToPeer = peer => {\n    // var dataChannelOptions = {\n    //   reliable: true\n    // };\n\n    let dataChannel = connection.createDataChannel(\"messenger\");\n\n    dataChannel.onerror = error => {\n      setAlert(\n        <SweetAlert\n          warning\n          confirmBtnBsStyle=\"danger\"\n          title=\"Failed\"\n          onConfirm={closeAlert}\n          onCancel={closeAlert}\n        >\n          An error has occurred.\n        </SweetAlert>\n      );\n    };\n\n    dataChannel.onmessage = handleDataChannelMessageReceived;\n    updateChannel(dataChannel);\n\n    connection\n      .createOffer()\n      .then(offer => connection.setLocalDescription(offer))\n      .then(() =>\n        send({ type: \"offer\", offer: connection.localDescription, sender: me, peer })\n      )\n      .catch(e =>\n        setAlert(\n          <SweetAlert\n            warning\n            confirmBtnBsStyle=\"danger\"\n            title=\"Failed\"\n            onConfirm={closeAlert}\n            onCancel={closeAlert}\n          >\n            An error has occurred.\n          </SweetAlert>\n        )\n      )\n  }\n\n  const toggleConnectToPeer = userName => {\n    console.log(\"toggleConnection\")\n    if (connectedRef.current === userName) {\n      setConnecting(true);\n      setConnectedTo(\"\");\n      connectedRef.current = \"\";\n      setConnecting(false);\n    } else {\n      setConnecting(true);\n      setConnectedTo(userName);\n      connectedRef.current = userName;\n      handleConnectToPeer(userName);\n      setConnecting(false);\n    }\n  };\n\n  return (\n    <div className=\"App\">\n      {alert}\n      <Header as=\"h2\" icon>\n        <Icon name=\"users\" />\n        <a href=\"https://webmonetization.org/docs/getting-started.html\" target=\"_blank\" rel=\"noopener noreferrer\">Web Monetization</a> Chat\n      </Header>\n      <MonetizationOff/>\n      {(socketOpen && (\n        <Fragment>\n          <Grid centered columns={2}>\n            <Grid.Column>\n              {(!isLoggedIn && (\n                <>\n                <Form>\n                <Form.Field>\n                <Label pointing=\"below\">Username is your chat alias (authentication not enabled yet)</Label>\n                <Input icon='user' iconPosition='left'\n                  disabled={loggingIn}\n                  type=\"text\"\n                  onChange={e => setMe(e.target.value)}\n                  placeholder=\"Username...\"\n                  action\n                  autoFocus\n                >\n                </Input>\n                </Form.Field>\n                <Form.Field>\n                <Label pointing=\"below\"><a href=\"https://paymentpointers.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Payment Pointer</a> is your (optional) wallet address where you get paid when you chat</Label>\n                <Input icon='dollar' iconPosition='left'\n                  disabled={loggingIn}\n                  type=\"text\"\n                  onChange={e => setPaymentPointer(e.target.value)}\n                  placeholder=\"Payment Pointer\"\n                  action\n                >\n                </Input>\n                </Form.Field>\n                <Button\n                    color=\"teal\"\n                    disabled={!me || loggingIn}\n                    onClick={handleLogin}\n                  >\n                    <Icon name=\"sign-in\" />\n                    Login\n                  </Button>\n                </Form>\n                </>\n              )) || (\n                <Segment raised textAlign=\"center\" color=\"olive\">\n                  Logged In as: {me} {paymentPointer}\n                </Segment>\n              )}\n            </Grid.Column>\n          </Grid>\n          <Grid>\n            <UsersList\n              users={users}\n              toggleConnection={toggleConnectToPeer}\n              connectedTo={connectedTo}\n              connection={connecting}\n            />\n            <MessageBox\n              messages={messages}\n              connectedTo={connectedTo}\n              message={message}\n              setMessage={setMessage}\n              sendMsg={sendMsg}\n              me={me}\n            />\n          </Grid>\n        </Fragment>\n      )) || (\n        <Loader size=\"massive\" active inline=\"centered\">\n          Connecting to messaging service...\n        </Loader>\n      )}\n    </div>\n  );\n};\n\nexport default Chat;\n","import React from \"react\";\nimport Chat from \"./Chat\";\nimport { ConnectionConsumer, ChannelConsumer} from \"./App\";\n\nconst Container = () => {\n  return (\n    <ConnectionConsumer>\n      {({ connection, updateConnection }) => (\n        <ChannelConsumer>\n          {({ channel, updateChannel }) => (\n            <Chat\n              connection={connection}\n              updateConnection={updateConnection}\n              channel={channel}\n              updateChannel={updateChannel}\n            />\n          )}\n        </ChannelConsumer>\n      )}\n    </ConnectionConsumer>\n  );\n};\n\nexport default Container","import React, { useState, createContext } from \"react\";\nimport Container from \"./Container\";\nimport { MonetizeProvider } from 'react-monetize'\n\nconst ConnectionContext = createContext({\n  connection: null,\n  updateConnection: () => {}\n});\nconst ChannelContext = createContext({\n  channel: null,\n  updateChannel: () => {}\n});\n\nconst App = () => {\n  const [connection, setconnection] = useState(null);\n  const [channel, setChannel] = useState(null);\n  const updateConnection = conn => {\n    setconnection(conn);\n  };\n  const updateChannel = chn => {\n    setChannel(chn);\n  };\n  return (\n    <ConnectionContext.Provider value={{ connection, updateConnection }}>\n      <ChannelContext.Provider value={{ channel, updateChannel }}>\n      <MonetizeProvider paymentPointer=\"$coil.xrptipbot.com/da75ae04-5c0c-4662-8ce6-5470a4127d97\">\n        <Container />\n      </MonetizeProvider>\n      </ChannelContext.Provider>\n    </ConnectionContext.Provider>\n  );\n};\n\nexport const ConnectionConsumer = ConnectionContext.Consumer\nexport const ChannelConsumer = ChannelContext.Consumer\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import 'semantic-ui-css/semantic.min.css'\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}